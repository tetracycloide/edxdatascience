
The terminal helps to organize files in the system.
On Mac, use utilities > terminal.
On windows, use Git bash program.
Use the keyboard to navigate the command line.
Code: 
echo "hello world"
We refer to all the files, folders, and programs (executables) on your computer as the filesystem.
Your filesystem is organized as a series of nested folders each containing files, folders, and executables. (see the visualization in the textbook)
In Unix, folders are referred to as directories and directories that are inside other directories are often referred to as subdirectories. 
The home directory is where all your stuff is kept.  There is a hierarchical nature to the file system.
Note for Windows Users: The typical R installation will make your Documents directory your home directory in R. This will likely be different from your home directory in Git Bash. Generally, when we discuss home directories, we refer to the Unix home directory which for Windows, in this book, is the Git Bash Unix directory.
The working directory is the current location.
Each terminal window has a working directory associated with it.
The "pwd" command will display your working directory. The "/" symbol separates directories, while the first "/" at the beginning of the path stands for the root directory. When a path starts with "/", it is a "full path", which finds the current directory from the root directory. "Relative path" will be introduced soon.
"~" means the home directory.

ls #list dir content
mkdir folder_name #create directory called "folder_name"
rmdir folder_name  #remove an empty directory as long as it is empty
rm -r folder_name  #remove dir that is not empty, "r" stands for recursive
cd: change dir
../ # two dots represents parent dir
. # single dot represents current workingdir 
cd ~/projects # concatenate with forward slashes
cd ../.. # change to two parent layer beyond
cd -  # whatever dir you were before
cd  # return to the home dir

Key points
The mv command moves files.
[warning] mv will not ask you to confirm the move, and it could potentially overwrite a file.
The rm command removes files.
[warning] rm is permanent, which is different than throwing a folder in the trash.
Code
mv path-to-file path-to-destination-directory
rm filename-1 filename-2 filename-3

less allows you to quickly look at the content of a file
Use q to exit the less page
use the arrows to navigate in the less page
Code
less cv.tex

Key points
Ideally, files (code, data, output) should be structured and self-contained
In a project, we prefer using relative paths (path relative to the default working directory) instead of the full path so that code can run smoothly on other individual's computers.
It is good practice to write a README.txt file to introduce the file structure to facilitate collaboration and for your future reference.
Code
########### In terminal ###########
cd ~    # move to home directory
mkdir projects    # make a new directory called projects
cd projects    # move to ~/projects directory
mkdir murders    # make new directory called murders inside of projects
cd murders    # move to ~/projects/murders/
mkdir data rda    # make two new directories, one is data the other is rda folder
ls    # to check if we indeed have one data folder and one rda folder
pwd    # check the current working directory
mkdir figs    # make a directory called figs to store figures
########## In RStudio ########
# pick existing directory as new project
getwd()    # to confirm current working directory
save()    # save into .rda file, .RData is also fine but less preferred
ggsave("figs/barplot.png")    # save a plot generated by ggplot2 to a dir called "figs"

R Markdown is a format for literate programming documents. Literate programming weaves instructions, documentation and detailed comments in between machine executable code, producing a document that describes the program that is best for human understanding.

Start an R markdown document by clicking on File > New File > the R Markdown

The output could be HTML, PDF, or Microsoft Word, which can be changed in the header output, e.g. pdf_document / html_document/p>

Code
# a sample code chunk
```{r}
summary(pressure)
```

# When echo=FALSE, code will be hided in output file
```{r echo=FALSE}
summary(pressure)
```

# use a descriptive name for each chunk for debugging purpose
```{r pressure-summary}
summary(pressure)
```

example file:
---
title: "Report on Gun Murders"
author: "Rafael Irizarry"
date: "`r format(Sys.Date())`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This is a report on 2010 gun murder rates obtained from FBI reports. The original data was obtained from [this Wikipedia page](https://en.wikipedia.org/wiki/Murder_in_the_United_States_by_state).

We are going to use the following library:

```{r loading-libs, message=FALSE}
library(tidyverse)
```
  
and load the data we already wrangled:

```{r}
load("rdas/murders.rda")
```

## Murder rate by state 

We note the large state to state variability by generating a barplot showing the murder rate by state:

```{r murder-rate-by-state, echo=FALSE}
murders %>% mutate(abb = reorder(abb, rate)) %>%
  ggplot(aes(abb, rate)) +
  geom_bar(width = 0.5, stat = "identity", color = "black") +
  coord_flip()
```

Other output options:
output: html_document 
output: pdf_document 
output: word_document
output: github_document

git and github
Recap: there are four stages: working directory, staging area, local repository, and upstream repository
Clone an existing upstream repository (copy repo url from clone button, and type "git clone <url>"), and all three local stages are the same as upstream remote.
The working directory is the same as the working directory in Rstudio. When we edit files we only change the files in this place.
git status: tells how the files in the working directory are related to the files in other stages
edits in the staging area are not tracked by the version control system by default - we add a file to the staging area by git add command
git commit: to commit files from the staging area to local repository, we need to add a message stating what we are doing by git commit -m "something"
git log: keeps track of all the changes we have made to the local repository
git push: allows moving from the local repository to upstream repository, only if you have the permission (e.g. if it is yours)
git fetch: update local repository to  be like the upstream repository, from upstream to local
git merge: make the updated local sync with the working directory and staging area
To change everything in one shot (from upstream to working dir), use git pull (equivalent to combining git fetch + git merge)
Code
pwd
mkdir git-example
cd git-example
git clone https://github.com/rairizarry/murders.git
cd murders
ls
git status
echo "test" >> new-file.txt
echo "temporary" >> tmp.txt
git add new-file.txt
git status
git commit -m "adding a new file" 
git status
echo "adding a second line" >> new-file.txt
git commit -m "minor change to new-file" new-file.txt
git status
git add
git log new-file.txt
git push
git fetch
git merge

Recap: two ways to get started, one is cloning an existing repository, the other is initializing our own
Create our own project on our computer (independent of Git) on our own machine
Create an upstream repo on Github, copy repo's url
Make a local git repository: On the local machine, in the project directory, use git init. Now git starts tracking everything in the local repo.
Now we need to start moving files into our local repo and connect local repo to the upstream remote by  git remote add origin <url>
Note: The first time you push to a new repository, you may also need to use these git push options: git push --set-upstream origin master. If you need to run these arguments but forget to do so, you will get an error with a reminder.
Code
cd ~/projects/murders
git init
git add README.txt
git commit -m "First commit. Adding README.txt file just to get started"
git remote add origin "https://github.com/rairizarry/murders.git"
git push    # you may need to add these arguments the first time: --set-upstream origin master

Advanced Unix
Arguments typically are defined using a dash (-) or two dashes (--) followed by a letter of a word.
r: recursive. For example, rm -r <directory-name>: remove all files, subdirectories, files in subdirectories, subdirectories in subdirectories, etc.
Combine arguments: rm -rf directory-name
ls -a: Shows all files in the directories including hidden files (e.g. .git file when initializing using git init) (a for all).
ls -l: Returns more information about the files (i.e. l for long).
ls -t: Shows files in chronological order.
ls -r: Reverses the order of how files are shown.
ls -lart: Shows more information for all files in reverse chronological order.

Getting Help: Use man + command name to get help (e.g. man ls). Note that it is not available for Git Bash. For Git Bash, you can use command -- help (e.g. ls --help).
Pipes: Pipes the results of a command to the command after the pipe. Similar to the pipe %>% in R. For example, man ls | less (and its equivalent in Git Bash: ls --help | less). Also useful when listing files with many files (e.g ls -lart | less).

* means any number of any combination of characters. Specifically, to list all html files: ls *.html and to remove all html files in a directory: rm *.html.
? means any single character. For example, to erase all files in the  form file-001.html with the numbers going from 1 to 999: rm file-???.html.
Combined wild cards: rm file-001.* to remove all files of the name file-001 regardless of suffix.
Warning: Combining rm with the * wild card can be dangerous. There are combinations of these commands that will erase your entire file system without asking you for confirmation. Make sure you understand how it works before using this wild card with the rm command.

In Unix, variables are distinguished from other entities by adding a $ in front. For example, the home directory is stored in $HOME.
See home directory: echo $HOME
See them all: env   
See what shell is being used: echo $SHELL (most common shell is bash)
Change environmental variables: (Don’t actually run this command though!) export PATH = /usr/bin/
In Unix, all programs are files. They are called executables. So, ls, mv, and git are all files.
To find where these program files are, use which. For example, which git would return /usr/bin/git.
Type ls /usr/bin to see several executable files. There are other directories that hold program files (e.g. Application directory for Mac or Program Files directory in Windows).
Type echo $PATH to see a list of directories separated by ":".
Type the full path to run the user-created executables (e.g ./my-ls).
Regular file -, directory d, executable x. 
This string also indicates the permission of the file: is it readable? writable? executable? Can other users on the system read the file? Can other users on the system edit the file? Can other users execute if the file is executable?
Be aware of common commands and know what they do.
open/start - On the mac open filename tries to figure out the right application of the filename and open it with that application. This is a very useful command. On Git Bash, you can try start filename. Try opening an R or Rmd file with open or start: it should open with RStudio.
nano - A bare-bones text editor.
ln - create a symbolic link. We do not recommend its use, but you should be familiar with it.
tar - archive files and subdirectories of a directory into one file.
ssh - connect to another computer.
grep - search for patterns in a file.
awk/sed - These are two very powerful commands that permit you to find specific strings in files and change them.